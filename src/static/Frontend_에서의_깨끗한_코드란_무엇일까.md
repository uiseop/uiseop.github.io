---
title: '신입 프론트엔드 개발자 입장에서 생각하는 클린 코드'
date: '2023-12-28'
author: 'uiseop'
categories: [react, clean code]
summary: '성숙한 개발자가 되기 위한 덕목 중 하나인 클린 코드, 신입 입장에서 이해한 클린 코드란? 프론트엔드 입장에서 클린 코드를 어떻게 적용할 수 있을지에 대한 고찰'
urlTitle: '신입-프론트엔드-개발자가-생각하는-클린-코드'
---

## Introduction

여러 클린한 아키텍쳐, 클린한 코드, 우아한 설계, 객체지향 이론과 관련된 서적을 보면 공통적으로

> `개발자`의 삶에서 `새로운 기능`을 만드는 시간보다 `유지 보수`를 하는데 드는 시간이 차지하는 비율이 훨씬 많다.

책을 쓰신 분들, 그리고 이러한 책들이 많이 팔렸다는 것은 그만큼 공감과 신뢰도가 높은 서적이라는 의미를 내포하고 있는데, 그러한 서적들에서 이구동성으로 위와 같은 말을 하곤 합니다.

그러면, 도대체 실무에서 어떤 일들이 발상해고 있길래.. 개발자들은 새로운 기능을 개발하기 보다는 유지보수에 더 많은 시간을 사용하고 있는 것 일까요?

## 새로운 기능을 추가하기 보다 수정하는 것이 어렵다.

> “프로그램이 동작하도록 만드는 데 엄청난 수준의 지식과 기술이 필요하지는 않다. 언제든 어린 고등학생이라도 할 수 있는 일이다. (...) 전 세계의 수많은 초급 프로그래머가 칸막이로 나뉜 작은 사무실에서 이슈 추적 시스템에 등록된 거대한 요구사항 문서들을 순전히 강인한 정신력만으로 힘겹게 해결해 내면서 시스템을 '동작'하도록 만든다. 이들이 작성한 코드는 그다지 깔끔하지 않을 순 있지만, 동작은 한다. 프로그램을 동작하게 만들기는 그리 어려운 일이 아니기 때문이다.” - 클린 아키텍처, 2p

생각해보면 어떻게는 `동작/실행`이 되게끔 만드는 것은 그리 어려운 일이 아닙니다. 하지만, 그렇게 동작하게끔 만든 제품을 조금만 다른 위치에 쓰려면 불가능한 경우가 많습니다. 기존에 사용하고 있던 조건이 변경되거나 아니면 어떤 정책이 조금만 바뀌어 그에 맞게끔 살짝 수정하여 바꾸려해도 수많은 파일에 영향(`side-effect`)을 미쳐 결국 대공사가 일어나게 될 수 있습니다. 이는 프로젝트의 크기가 커지면 커질수록 이러한 상황이 더 자주 발생하게 될 수 있겠죠.

![배포를 거듭할 수록 코드 1줄을 수정하는데 들어가는 인건비가 기하급수적으로 증가한다](https://pbs.twimg.com/media/D9QqXcsWsAYXNSe?format=jpg&name=small)
_[배포를 거듭할 수록 코드 1줄을 수정하는데 들어가는 인건비가 기하급수적으로 증가한다](https://twitter.com/qntm/status/1140583349263765504)_

신입 입장에서 진행해왔던 프로젝트들은 보통 제한된 시간안에 제품을 만들어야하기 때문에 프로젝트의 크기가 작고, 이로인해 수정이 발생하더라도 적은 부분만을 수정하면 됐었기 때문에 유지보수/수정에 드는 비용이 클것이다라는 생각을 하지 못했었는데 이러한 그래프를 보니 왜 유지보수에 드는 비용이 새로운 기능을 만드는 것 보다 많이 드는지 어렴풋이 이해가 되기 시작했습니다.

### 그럼 처음부터 잘 설계하면 되지 않을까?

우리가 흔히 새로운 기술을 익힐 때 만들게 되는 `Todo List 앱`조차도 기본적인 사항에 약간의 요구사항만 추가하더라도 상당히 복잡해지기 십상입니다.

> “이해관계자는 범위가 비슷한 일련의 변경사항을 제시할 뿐이지만, 개발자 입장에서는 복잡도가 지속적으로 증가하는 퍼즐 판 위에서 이해관계자가 계속해서 퍼즐 조각을 맞추라는 지시를 하는 것처럼 느껴진다. 새로운 요청사항이 발생할 때마다 바로 이전의 변경사항을 적용하는 것보다 조금 더 힘들어지는데, 시스템의 형태와 요구사항의 형태가 서로 맞지 않기 때문이다.” - 클린 아키텍처, 17p

여기서 알 수 있는 두 가지 사실이 있습니다.

첫째, **1) 프로그램이 복잡해지는 이유는 애초에 우리의 현실 자체가 복잡하고, 코딩을 할 수록 그 복잡도가 제품에 점차 반영되기 때문**입니다. 다른 하나는 **2) 그 복잡함이 어느 정도까지 복잡해질지 요구 받아보기 전까지 절대 알 수 없기에 최적 구조를 미리 정할 수 없다**는 점입니다.

스파게티 코드를 짜고 싶어하는 개발자가 있진 않았을 겁니다. 하지만 실제 서비스 되고 있는 실무에서는 매일 새로운 인입이 들어오고 이에따라 새로운 기획, 변경된 기획안들이 제시되고 이를 처리하다보면 어느덧 처음 완벽하게 설계되어있다고 생각했던 구조가 맞지 않을 수 있겠죠.

언제나 우리는 시간의 압박과 제한적인 정보 속에서 안정적으로 기능을 만들어 나가야 합니다. 포인트는 잘 만드는 것(물론 맞지만)이 아니라 `리소스가 제한된 상황` 그 자체에 있었던 겁니다.

그리고 중요한 사실은 `리소스가 충분한 언젠가`는 오지 않습니다. 오지 않을 상황을 기다리는 것은 하지 않겠다는 의지의 표명에 다름 아닙니다.

그러면, `리소스가 충분한 언젠가`를 기다리기 보다는 지금 당장 제가 할 수 있는 행동은 무엇이 있을까요?

## 함수를 잘 나누자

우선 용어 정의를 하고 넘어가겠습니다.

- **1) 데이터 : 이벤트에 대한 사실. 문자열, 객체 등 단순한 값 그 자체.**
  - ex) 사용자가 입력한 이메일 주소, 은행 API로 읽은 달러 수량
- **2) 계산(Compute) : 입력으로 얻은 출력. 순수 함수, 수학 함수 라고 부르기도 함.**
  - ex) 최댓값 찾기, 이메일 주소가 올바른지 확인하기
- **3) 액션 : 외부 세계와 소통하므로 실행 시점과 횟수에 의존. 부수 효과를 일으킴.**
  - ex) 이메일 보내기, 데이터베이스 읽기, [setState](https://uiseop.github.io/%EC%99%9C-setState%ED%9B%85%EC%9D%80-sideEffect%EB%A5%BC-%EC%95%BC%EA%B8%B0%ED%95%A0%EA%B9%8C)

우리가 함수를 나눌 때 제법 잘 나눠졌다고 생각이 들 때도 있고, 그렇지 않을 때도 있습니다. 후자의 경우를 유심히 들여다 보면 아마 `액션`에 해당하는 로직이 섞여 있는 경우가 많지 않을까 싶습니다.

우리는 데이터, 계산으로부터 가급적 액션을 분리하고, `부수 효과를 일으키는` 액션 안에서 데이터나 계산 로직을 호출하여 사용하도록 분리하면 좋겠습니다.

`부수 효과를 일으키는 것`과 없는것을 분리하면 다음과 같은 이점을 얻을 수 있습니다.

`부수 효과`가 없으면 외부에 영향을 주지 않기 때문에 **1) 쉽게 테스트 가능**하고 **2) 여러 번 테스트해도 문제가 생기지 않**습니다. 반면 액션은 **1) 실행 시점**과 **2) 횟수에 따라 결과가 다르게 나올 수 있으**며 **외부 세계에 영향**을 주기 때문에 재현하기 위해서는 많은 노력이 필요(= 테스트 하고자 하는 로직 뿐만 아니라 외부 세계를 함께 재현해야 하기 때문에)합니다.

![가오나시](https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRxU8IRqYh3P1cBZk669F2z-rFyRfaDnPKk9g&usqp=CAU)

액션이란 프로그래밍으로 우리가 계산해낸 것들을 외부 세계에 전달하거나 전달 받는 동작으로서, 우리가 원하는 일을 달성하기 위해서는 꼭 필요하지만, 가급적이면 접촉면을 작게 해야하는 애증의 존재이기 때문에 가급적이면 액션에 해당하는 로직을 분리하도록 신경쓰는 것으로 `함수를 잘 나눌 수 있겠다`고 생각했습니다.

이렇게 함수를 나누면 부수 효과가 없는 데이터나 계산을 담당하는 함수는 컴포넌트 외부에 위치할 수 있겠고, 자연스럽게 `재사용(테스트)`할 수 있는 효과까지 얻을 수 있겠습니다.

## 좋은 코드를 접하자

회사에 들어가면 선임 개발자 혹은 동료들에게 코드 리뷰를 받으면서 동시에 그들의 코드를 리뷰해주면서 내 코드에서 부족한 부분, 개선할 수 있는 부분들을 깨닫게 될 수 있을것 입니다. 그래서 하루라도 빨리 취업을 목표로 하고 있고요.

하지만, 취준생 입장에서는 진득히 제 코드를 봐줄 동료분들을 구하는 것이 쉽지만은 않은 현실입니다. 봐줄 동료가 없다면, 좋은 코드를 보고 견문을 넓히는 방법을 선택해야 했습니다. 좋은 코드는 이미 제 주위에 많이 널려 있으니깐요. 바로 유명 라이브러리를 까보는 것 입니다.

제가 구현하려고 하는 모든 기능들은 실제 라이브러리로 구현되어 있고, 제가 직접 개발하는 것 보다는 무수히 많은 별을 받고, 실제 기업에서 사용되고 있는 코드들이 더 좋은 코드일것이기 때문입니다. 이러한 코드들은 앞서 이야기했던 `유지보수` 측면에 더욱이 신경을 썼을 것 이고요.

이러한 이유로 이 블로그를 개발하면서 실제 라이브러리의 코드를 들여다 보는 시간을 갖게 되었습니다. 일단 두 라이브러리를 살펴 보았는데요, Toast 알림을 띄워주는 `React-toastify`와 카테고리 목록을 가로로 스크롤 할 수 있는 기능을 `MUI-core` 라이브러리를 참고해서 특정 기능들을 개발했습니다.

저보다 많이 공부하시고 현업에서 일하시는 개발자가 작성하신 코드를 바라보면서 **'와 이렇게도 로직을 작성할 수 있겠구나 / 이렇게 문제를 해결할 수 있겠구나?'** 등의 코드를 작성하는 새로운 시각을 얻을 수 있었습니다. `백문이불여일견`이라는 말이 있듯이 아무리 백마디 말을 통해 내 코드의 어떤 부분이 좋지 않은지 설명해주기 보다는 우선 그런 추상화된 리뷰를 이해할 수 있도록 `좋은 코드`를 먼저 접해보고 실무에 투입된다면 더 나은 의사소통을 할 수 있겠다는 생각이 들었습니다.

### 추상화

프로그래밍은 복잡하고 어려운 `컴퓨터 세계`를 사람이 이해하고자 `현실세계의 무엇인가를 빗대어 표현`하곤 합니다.

하지만, 단순히 어림잡아 빗대어 표현하는것 만으로는 부족할 수 있습니다. 현실 세계에서도 이러한 문제들이 있는데 가령 최근 가장 화두가 되었던 인공지능을 표현하는 예시를 보면 예전에는 알파고라고 부르고 지금은 이제 너도나도 GPT라도 하면 알아 듣듯이, 새로운 용어로 재정의하고 다들 그것을 알아 듣습니다.

이처럼 우리가 복잡한 컴퓨터 세상을, 코드 세상을 좀 더 편리하게 이해할 수 있게 하기 위해서는 그 무엇보다 해당 코드들이 `어떤 역할과 의미`를 갖고 있는지 빠르게 파악해야 하고 `역할과 의미를 바탕으로 분류`해야지만이 이해하기 쉽고, 이해하기 쉬워지면 앞서 가장 시간이 많이 들던 `유지 보수`에 사용되는 시간을 줄일 수 있게 됩니다.

물론, 실무에서는 대체로 그런 시간들이 넉넉히 주어지지는 않는다고 하고, 막상 시간을 넉넉히 주더라도 만족할만한 결과를 내지 못할 가능성도 크다고 합니다. 대학교 이론을 초등학생도 이해할 수 있게끔 설명하는 것이 더 어렵듯이 복잡하게 얽힌 코드를 누구나 이해하기 쉽고, 수정하기 쉬운 코드로 변경하는것은 굉장히 어려운 일이기 때문입니다.
